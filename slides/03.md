[Previous: Why range over func?](./02.md)

# Can't we make use of existing mechanisms?

There are existing ways to iterate over values, can't we just use one of them?

Technically yes, but they all come with their own drawbacks.

## Creating an array, a slice or a map

Create an array, a slice or a map (in the next paragraphs all of these are referred to as a _collection_) and iterate over that. What are the drawbacks?

You _must_ create the whole collection beforehand. Let's say you want to iterate over a directory and its subdirectories to find a file with a filename that matches a certain pattern, then show its contents and exit. Potentially you'd create a giant slice with thousands or tens of thousands of file infos, just to find that the first one is the one you wanted. Highly inefficient.

Obviously it cannot work with potentially infinite values, e.g. modelling the natural numbers. Even when relying on `int64` instead of `big.Int` and starting at 1, a slice would contain 9223372036854775807 `int64`s. Assuming one value needs 8 bytes, this would result in a memory usage of 68,719,476,735 GiB, not really feasible.

Iteration happens on a snapshot. As soon as the collection is created, it is independent from its source. This may or may not be a problem.

Utility functions for filtering or mapping values either have to create a second collection, resulting in memory usage spikes, or destroy the old collection while creating the new one, making implementations more complex and unintuitive.

Two-valued iterations are limited to `comparable, any` pairs instead of `any, any`. Map keys must be `comparable` and the first value of a `range` over a slice or an array is `int` (which happens to be `comparable`). In addition, anything other than `int, any` cannot be iterated with a pre-determined order as map iteration is random.

## Using a channel

Provide a channel for a consumer to pull values from. What are the drawbacks?

Channels make use of synchronization mechanisms, leading to a bit of overhead. Usually a Go routine is involved to push the values.

Iteration may end before all values have been pushed, so there must be a way to stop the source. There are several ways to do this, e.g. just letting the consumer close the channel (dangerous, as it can be forgotten easily), or by providing a cancel function.

Utility functions for filtering or mapping values typically involve additional Go routines and add even more synchronization overhead.

Limited to iterating over a single value. There's no two-valued iteration.

[Next: How do we use them?](./04.md)
